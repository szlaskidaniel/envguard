# EnvGuard CLI
**Static Analysis for Environment Variables**

Keep your environment variables in sync with your codebase.


## The Problem

- `.env.example` is always out of sync with actual `.env`
- New developers don't know what environment variables they need
- Production secrets accidentally committed
- Dead environment variables cluttering your config

## The Solution

EnvGuard automatically:
- Scans your codebase for `process.env.*` usage
- Compares with your `.env` and `.env.example` files
- **Supports Serverless Framework** - scans `serverless.yml` environment configurations
- Alerts you to missing, unused, or undocumented variables
- Auto-generates `.env.example` with helpful comments
- **Supports multiple `.env` files** in subdirectories (monorepo-friendly!)

## Installation

**Option 1: Install globally**

```bash
npm install -g @danielszlaski/envguard
```

After installation, use the short command:
```bash
envguard scan
```

**Option 2: Use with npx (no installation needed)**

```bash
npx @danielszlaski/envguard scan
```

## Usage

> **Note:** The examples below use `envguard` (short form), which works after installation. If using npx without installation, use `npx @danielszlaski/envguard` instead.

### Git Hook Integration (Pre-commit/Pre-push)

Automatically run envguard before every commit or push to catch environment variable issues early:

```bash
# Install a pre-commit hook (runs before each commit)
envguard install-hook

# Or install a pre-push hook (runs before each push)
envguard install-hook --type pre-push

# Force overwrite existing hook
envguard install-hook --force
```

Once installed, the hook will automatically run `envguard check` before each commit (or push). If issues are found, the commit/push will be blocked until you fix them.

**Bypass the hook** when needed:
```bash
git commit --no-verify
git push --no-verify
```

**Remove the hook:**
```bash
envguard uninstall-hook

# Or for pre-push hook
envguard uninstall-hook --type pre-push
```

**How it works:**
- The hook creates a script in `.git/hooks/pre-commit` (or `pre-push`)
- Before each commit/push, it runs `envguard check`
- If issues are found, the operation is blocked
- Team members need to install the hook individually (it's not tracked in git)

### Scan for issues

```bash
envguard scan
```

Example output:

```
✔ Found 1 .env file(s) and 0 serverless.yml file(s)

Checking ./

   Found 12 variable(s) used in this scope
   Found 10 variable(s) in .env
   Found 8 variable(s) in .env.example

   ✖ Missing from .env:
      • STRIPE_SECRET_KEY
   Used in: src/payment.js, src/checkout.ts
      • API_KEY
   Used in: src/api/client.ts

   ⚠ Unused variables:
      • OLD_API_URL

   Missing from .env.example:
      • DATABASE_URL
      • JWT_SECRET

──────────────────────────────────────────────────

⚠ Total: 5 issue(s) across 1 location(s)

Run `envguard fix` to auto-generate .env.example
```

### Auto-generate .env.example

```bash
envguard fix
```

This will create/update `.env.example` files with:
- All environment variables used in your code
- Comments showing where each variable is used
- Format hints for common variable types (URLs, ports, etc.)
- **Creates `.env.example` next to each `.env` file** (great for monorepos!)

Example generated `.env.example`:

```bash
# Auto-generated by envguard
# Do not put actual secrets in this file - use .env instead

# Used in: src/db/connection.ts:12, src/models/user.ts:5
# Format: postgresql://user:pass@host:5432/db
DATABASE_URL=

# Used in: src/payment.js:23
# Format: sk_test_...
STRIPE_SECRET_KEY=

# Used in: src/server.ts:8
# Format: 3000
PORT=
```

### CI/CD Integration

Use the `check` command in your CI pipeline to fail builds if environment variables are out of sync:

```bash
envguard check
```

This is equivalent to `envguard scan --ci` and will exit with code 1 if issues are found.

## GitHub Actions Setup

EnvGuard integrates seamlessly with GitHub Actions to validate your environment variables on every pull request or push.

### Quick Setup (Recommended)

Create `.github/workflows/envguard.yml` in your repository:

```yaml
name: Environment Variables Check

on:
  pull_request:
    branches: [main]
  push:
    branches: [main, develop]

jobs:
  envguard:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Run EnvGuard check
        run: npx @danielszlaski/envguard scan --ci
```

**That's it!** No installation needed - `npx` downloads EnvGuard on demand.

### Advanced Setup - With PR Comments

Get automatic comments on pull requests when issues are found:

```yaml
name: Environment Variables Check

on:
  pull_request:
    branches: [main]

jobs:
  envguard:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      
      - name: Run EnvGuard scan
        id: envguard
        continue-on-error: true
        run: |
          OUTPUT=$(npx @danielszlaski/envguard scan 2>&1)
          echo "$OUTPUT"
          echo "output<<EOF" >> $GITHUB_OUTPUT
          echo "$OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          npx @danielszlaski/envguard scan --ci
      
      - name: Comment on PR if failed
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## ⚠️ EnvGuard Check Failed\n\n```\n${{ steps.envguard.outputs.output }}\n```\n\nPlease run `npx @danielszlaski/envguard fix` locally to generate `.env.example` files, then commit the changes.'
            })
```

### Strict Mode in CI

Enable strict mode to catch all variables including runtime-provided ones:

```yaml
- name: Run EnvGuard check (strict)
  run: npx @danielszlaski/envguard scan --ci --strict
```

### Weekly Audit

Schedule weekly checks to catch configuration drift:

```yaml
name: Weekly Environment Audit

on:
  schedule:
    - cron: '0 9 * * MON' # Every Monday at 9am UTC

jobs:
  audit:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      - run: npx @danielszlaski/envguard scan --ci --strict
      
      - name: Create issue if problems found
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '⚠️ Environment Variables Out of Sync',
              body: 'Weekly EnvGuard audit found issues. Run `npx @danielszlaski/envguard scan` locally for details.',
              labels: ['env-config', 'maintenance']
            })
```

### Caching for Faster Runs

Speed up CI runs by caching npx downloads:

```yaml
- name: Setup Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
    cache: 'npm'  # Caches npx downloads

- name: Run EnvGuard
  run: npx @danielszlaski/envguard scan --ci
```

### Other CI Platforms

**GitLab CI** (`.gitlab-ci.yml`):
```yaml
envguard:
  image: node:20
  script:
    - npx @danielszlaski/envguard scan --ci
  only:
    - merge_requests
```

**CircleCI** (`.circleci/config.yml`):
```yaml
version: 2.1
jobs:
  envguard:
    docker:
      - image: cimg/node:20.0
    steps:
      - checkout
      - run: npx @danielszlaski/envguard scan --ci
```

**Travis CI** (`.travis.yml`):
```yaml
language: node_js
node_js:
  - '20'
script:
  - npx @danielszlaski/envguard scan --ci
```

## Supported Languages & Frameworks

### JavaScript/TypeScript
- JavaScript (`.js`, `.mjs`, `.cjs`)
- TypeScript (`.ts`, `.tsx`)
- JSX (`.jsx`)

Detects:
- `process.env.VAR_NAME`
- `process.env['VAR_NAME']`
- `const { VAR_NAME } = process.env`

### Serverless Framework
- Automatically detects `serverless.yml` and `serverless.yaml` files
- Scans `provider.environment` section
- Scans function-level `environment` sections
- Detects references to external sources (SSM, Secrets Manager, etc.)
- Validates that all defined variables are used in code
- Reports variables used in code but not defined in serverless.yml

## Configuration

EnvGuard works out of the box with sensible defaults. It automatically excludes:
- `node_modules`
- `dist`
- `build`
- `.git`

### Custom Configuration

Create a `.envguardrc.json` file in your project root to customize behavior:

```json
{
  "ignoreVars": [
    "MY_CUSTOM_VAR",
    "ANOTHER_VAR",
    "COMPANY_INTERNAL_VAR"
  ],
  "strict": false,
  "detectFallbacks": true,
  "exclude": [
    "**/build/**",
    "**/tmp/**"
  ]
}
```

**Configuration options:**

- `ignoreVars` (string[]): Custom environment variables to ignore in non-strict mode. These will be treated like AWS_REGION and won't trigger warnings.
- `strict` (boolean): Enable strict mode by default (can be overridden with CLI flag)
- `detectFallbacks` (boolean): Detect fallback patterns in code and treat them as warnings instead of errors (default: `true`)
- `exclude` (string[]): Additional file patterns to exclude from scanning

**Alternative: package.json**

You can also add configuration to your `package.json`:

```json
{
  "envguard": {
    "ignoreVars": ["MY_CUSTOM_VAR"],
    "strict": false
  }
}
```

**Use case for ignoreVars:**
- Company-wide variables that are always available (injected by infrastructure)
- Framework-specific variables you don't need to track
- Variables provided by your deployment platform (Vercel, Netlify, etc.)
- Custom variables for GitHub Apps or CI/CD integrations

**Priority:** CLI flags > `.envguardrc.json` > `package.json` > defaults

**GitHub Apps & CI/CD:**
When using EnvGuard as a GitHub App or in CI/CD pipelines, commit your `.envguardrc.json` to the repository. This ensures consistent behavior across all environments and team members.

### Fallback Detection (Smart Severity)

EnvGuard automatically detects common defensive patterns in your code and adjusts issue severity accordingly. When a variable is used with a fallback or default value, it's treated as a **WARNING** instead of an **ERROR**.

**Detected patterns:**

```javascript
// Default values with || or ??
const port = process.env.PORT || 3000;              // WARNING
const url = process.env.API_URL ?? 'localhost';     // WARNING

// Ternary operators
const env = process.env.NODE_ENV ? 'set' : 'dev';   // WARNING

// Conditional checks
if (process.env.FEATURE_FLAG) { }                   // WARNING
if (!process.env.DEBUG) { }                         // WARNING

// Destructuring with defaults
const { LOG_LEVEL = 'info' } = process.env;         // WARNING

// Optional chaining
const value = process.env?.OPTIONAL_VAR;            // WARNING

// No fallback - strict requirement
const apiKey = process.env.API_KEY;                 // ERROR
```

**Severity levels:**

- **ERROR** (✖): Variable used without any safety mechanism - likely to cause runtime errors
- **WARNING** (⚠): Variable used with fallback/default - code handles missing values
- **INFO** (ℹ): Unused variables or optional documentation issues

**Disable fallback detection:**

If you prefer all missing variables to be treated as errors regardless of fallbacks:

```bash
# CLI flag
envguard scan --no-detect-fallbacks

# Config file
{
  "detectFallbacks": false
}
```

**Why this feature exists:**

Not all missing environment variables are equal. Variables with defensive fallbacks are less critical than those that will cause `undefined` errors. This feature helps you prioritize what to fix first while still being aware of all env var usage.

**Limitations:**

Fallback detection uses regex patterns and catches common cases (~80% of real-world usage). Complex patterns like function calls with fallbacks or deeply nested conditionals may not be detected. For strict validation, use `--no-detect-fallbacks` or set `detectFallbacks: false` in your config.

### Monorepo Support

EnvGuard automatically detects all `.env` files in your project, including subdirectories. When you run `envguard fix`, it creates a `.env.example` file next to each `.env` file it finds.

Example structure:
```
project/
├── .env              → generates .env.example
├── src/
│   └── lambda1/
│       ├── .env      → generates lambda1/.env.example
│       └── handler.js
└── services/
    └── api/
        ├── .env      → generates api/.env.example
        └── server.js
```

Each `.env.example` only includes variables used in that directory and its subdirectories.

## Serverless Framework Support

EnvGuard can scan `serverless.yml` files as a standalone source of environment variable definitions. This is useful for AWS Lambda projects where environment variables are defined in the serverless configuration rather than `.env` files.

### How it works

1. **Detects** `serverless.yml` files in your project
2. **Extracts** environment variables from `provider.environment` and function-level `environment` sections
3. **Validates** that all defined variables are actually used in your Lambda code
4. **Reports** unused variables and missing definitions

### Example serverless.yml

```yaml
provider:
  name: aws
  runtime: nodejs20.x
  environment:
    NODE_ENV: ${opt:stage}
    API_KEY: ${ssm:/my-app/api-key}
    DATABASE_URL: ${self:custom.dbUrl}
```

### Scan output for serverless.yml

```
Checking src/lambda/serverless.yml

   Found 3 variable(s) in serverless.yml
   Found 2 variable(s) used in code

   ⚠ Unused variables in serverless.yml:
      • DATABASE_URL

   ✖ Missing from serverless.yml:
      • LOG_LEVEL
   Used in: src/lambda/handler.js
```

### Key Features

- **No .env required** - serverless.yml is treated as a standalone configuration source
- **CloudFormation intrinsic functions** - Supports `!Ref`, `!GetAtt`, `!Sub`, `!ImportValue`, and all CF functions
- **External references** - Detects SSM parameters, Secrets Manager, CloudFormation outputs
- **Function-level variables** - Scans both provider-level and function-specific environment vars
- **Smart filtering** - Automatically skips AWS/runtime variables (disable with `--strict`)
- **CI/CD validation** - Use `envguard check` to enforce serverless config completeness

## Commands

- `envguard scan` - Scan for issues and display report
- `envguard scan --ci` - Scan and exit with error code if issues found
- `envguard scan --strict` - Report all variables including known runtime variables
- `envguard scan --no-detect-fallbacks` - Treat all missing variables as errors (ignore fallback detection)
- `envguard fix` - Auto-generate `.env.example`
- `envguard check` - Alias for `scan --ci`
- `envguard check --strict` - Check with strict mode enabled
- `envguard check --no-detect-fallbacks` - Check without fallback detection
- `envguard install-hook` - Install a Git pre-commit hook to run checks automatically
- `envguard install-hook --type pre-push` - Install a pre-push hook instead
- `envguard install-hook --force` - Overwrite existing hook if present
- `envguard uninstall-hook` - Remove the envguard Git hook
- `envguard uninstall-hook --type pre-push` - Remove the pre-push hook

### Strict Mode

By default, EnvGuard filters out well-known runtime variables that don't need to be explicitly defined:

**AWS Lambda variables**: `AWS_REGION`, `AWS_LAMBDA_FUNCTION_NAME`, etc.
**Node.js runtime**: `NODE_ENV`, `PATH`, etc.
**CI/CD environments**: `CI`, `GITHUB_ACTIONS`, etc.
**Serverless Framework**: `IS_OFFLINE`, `SLS_OFFLINE`, etc.

Use `--strict` mode to report ALL variables including these runtime-provided ones:

```bash
envguard scan --strict
```

Example output (non-strict):
```
   Skipped known runtime variables (use --strict to show):
   Serverless Framework: IS_OFFLINE, SLS_OFFLINE
   CI/CD: CI
   AWS Lambda: AWS_REGION
```

## Development

```bash
# Install dependencies
npm install

# Build
npm run build

# Run locally
npm start scan
```

## License

MIT 2026 Daniel Szlaski
