import { Issue, ScanResult } from '../types';
import { EnvEntry } from '../parser/envParser';

export class EnvAnalyzer {
  analyze(
    usedVars: Map<string, { locations: string[], hasFallback: boolean }>,
    definedVars: Map<string, EnvEntry>,
    exampleVars: Set<string>,
    detectFallbacks: boolean = true
  ): ScanResult {
    const issues: Issue[] = [];

    // Issue 1: Variables used in code but missing from .env
    for (const [varName, usage] of usedVars.entries()) {
      if (!definedVars.has(varName)) {
        // If detectFallbacks is enabled and variable has a fallback, it's a WARNING, otherwise ERROR
        const severity = (detectFallbacks && usage.hasFallback) ? 'warning' : 'error';
        const details = (detectFallbacks && usage.hasFallback)
          ? `Used in code with fallback/default but not defined in .env`
          : `Used in code but not defined in .env`;

        issues.push({
          type: 'missing',
          severity,
          varName,
          details,
          locations: usage.locations,
        });
      }
    }

    // Issue 2: Variables defined in .env but never used
    for (const [varName] of definedVars.entries()) {
      if (!usedVars.has(varName)) {
        issues.push({
          type: 'unused',
          severity: 'info',
          varName,
          details: `Defined in .env but never used in code`,
        });
      }
    }

    // Issue 3: Variables used in code but not in .env.example
    for (const [varName, usage] of usedVars.entries()) {
      if (!exampleVars.has(varName)) {
        // If detectFallbacks is enabled and variable has a fallback, it's less critical for documentation
        const severity = (detectFallbacks && usage.hasFallback) ? 'info' : 'warning';
        const details = (detectFallbacks && usage.hasFallback)
          ? `Used in code with fallback but missing from .env.example`
          : `Used in code but missing from .env.example`;

        issues.push({
          type: 'undocumented',
          severity,
          varName,
          details,
          locations: usage.locations,
        });
      }
    }

    return {
      issues,
      usedVars,
      definedVars: new Set(definedVars.keys()),
      exampleVars,
    };
  }

  generateExampleContent(
    usedVars: Map<string, { locations: string[], hasFallback: boolean }>,
    existingEntries: Map<string, EnvEntry>
  ): string {
    let content = '# Auto-generated by envguard\n';
    content += '# Do not put actual secrets in this file - use .env instead\n\n';

    const sortedVars = Array.from(usedVars.keys()).sort();

    for (const varName of sortedVars) {
      const usage = usedVars.get(varName)!;
      const locations = usage.locations;
      const existingEntry = existingEntries.get(varName);

      // Add location comments
      content += `# Used in: ${locations.slice(0, 3).join(', ')}`;
      if (locations.length > 3) {
        content += ` (+${locations.length - 3} more)`;
      }
      content += '\n';

      // Add existing comment if available
      if (existingEntry?.comment) {
        content += `# ${existingEntry.comment}\n`;
      } else {
        // Add a format hint based on common patterns
        const hint = this.getFormatHint(varName);
        if (hint) {
          content += `# Format: ${hint}\n`;
        }
      }

      // Add the variable with empty value or existing value
      if (existingEntry) {
        content += `${varName}=${existingEntry.value}\n`;
      } else {
        content += `${varName}=\n`;
      }

      content += '\n';
    }

    return content;
  }

  private getFormatHint(varName: string): string | null {
    const patterns: { [key: string]: string } = {
      'DATABASE_URL': 'postgresql://user:pass@host:5432/db',
      'MONGODB_URI': 'mongodb://localhost:27017/dbname',
      'REDIS_URL': 'redis://localhost:6379',
      'PORT': '3000',
      'NODE_ENV': 'development|production|test',
      'API_KEY': 'your-api-key-here',
      'SECRET': 'your-secret-here',
      'JWT_SECRET': 'your-jwt-secret',
      'STRIPE_': 'sk_test_...',
      'AWS_': 'aws-credentials',
    };

    for (const [pattern, hint] of Object.entries(patterns)) {
      if (varName.includes(pattern)) {
        return hint;
      }
    }

    if (varName.endsWith('_URL') || varName.endsWith('_URI')) {
      return 'https://example.com';
    }

    if (varName.endsWith('_PORT')) {
      return '8080';
    }

    if (varName.endsWith('_KEY') || varName.endsWith('_SECRET') || varName.endsWith('_TOKEN')) {
      return 'your-secret-here';
    }

    return null;
  }
}
