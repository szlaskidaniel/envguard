import * as fs from 'fs';
import * as path from 'path';

export interface EnvEntry {
  key: string;
  value: string;
  comment?: string;
  lineNumber: number;
}

export class EnvParser {
  parse(filePath: string): Map<string, EnvEntry> {
    const envVars = new Map<string, EnvEntry>();

    if (!fs.existsSync(filePath)) {
      return envVars;
    }

    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');
      let currentComment = '';

      lines.forEach((line, index) => {
        const trimmed = line.trim();

        // Skip empty lines
        if (!trimmed) {
          currentComment = '';
          return;
        }

        // Capture comments
        if (trimmed.startsWith('#')) {
          currentComment = trimmed.substring(1).trim();
          return;
        }

        // Parse key=value
        const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=(.*)$/);
        if (match) {
          const key = match[1];
          let value = match[2];

          // Remove quotes if present
          if ((value.startsWith('"') && value.endsWith('"')) ||
              (value.startsWith("'") && value.endsWith("'"))) {
            value = value.slice(1, -1);
          }

          envVars.set(key, {
            key,
            value,
            comment: this.isUserComment(currentComment) ? currentComment : undefined,
            lineNumber: index + 1,
          });

          currentComment = '';
        }
      });
    } catch (error) {
      console.error(`Error parsing ${filePath}:`, error);
    }

    return envVars;
  }

  private isUserComment(comment: string): boolean {
    if (!comment) return false;

    // Filter out auto-generated comments to prevent duplicates when running fix multiple times
    const autoGeneratedPrefixes = ['Used in:', 'Format:', 'Auto-generated by'];
    return !autoGeneratedPrefixes.some(prefix => comment.startsWith(prefix));
  }

  parseExample(filePath: string): Set<string> {
    const envVars = new Set<string>();

    if (!fs.existsSync(filePath)) {
      return envVars;
    }

    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');

      lines.forEach(line => {
        const trimmed = line.trim();

        // Skip comments and empty lines
        if (!trimmed || trimmed.startsWith('#')) {
          return;
        }

        // Parse key=value
        const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)=/);
        if (match) {
          envVars.add(match[1]);
        }
      });
    } catch (error) {
      console.error(`Error parsing ${filePath}:`, error);
    }

    return envVars;
  }

  getExistingContent(filePath: string): string {
    if (!fs.existsSync(filePath)) {
      return '';
    }
    return fs.readFileSync(filePath, 'utf-8');
  }
}
